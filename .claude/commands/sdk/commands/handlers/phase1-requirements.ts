/**
 * CCAGI SDK Phase 1: Requirements Command Handlers
 *
 * Based on SDK_REQUIREMENTS.md v6.19.0
 * Commands: CMD-001 (generate-requirements), CMD-002 (add-requirements)
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { BaseCommandHandler } from '../base';
import { registerCommand } from '../registry';
import type {
  CommandContext,
  CommandHandlerResult,
  ValidationError,
} from '../types';
import { detectInputSource } from '../../core/input-detector';

// =============================================================================
// CMD-001: Generate Requirements
// =============================================================================

/**
 * Generate Requirements Handler
 *
 * Generates requirements documents from input source (URL, Issue, or document)
 */
export class GenerateRequirementsHandler extends BaseCommandHandler<{
  requirementsPath: string;
  sourceType: string;
}> {
  constructor() {
    super('CMD-001', '/generate-requirements');
  }

  protected async executeInternal(
    context: CommandContext
  ): Promise<
    CommandHandlerResult<{ requirementsPath: string; sourceType: string }>
  > {
    const inputUrl = context.options.url as string;

    // Detect input source type
    const detection = await detectInputSource(inputUrl, context.projectRoot);
    if (!detection.success) {
      return this.failure(new Error(detection.error || 'Failed to detect input source'));
    }

    context.logger.info(
      `Detected input source: ${detection.source.type} (confidence: ${detection.source.confidence})`
    );

    // Create output directory
    const outputDir = this.resolveOutputPath(context);
    await fs.mkdir(path.dirname(outputDir), { recursive: true });

    // Generate requirements based on source type
    const requirements = await this.generateRequirements(
      detection.source.type,
      detection.source.value,
      context
    );

    // Write requirements document
    const requirementsPath = path.join(
      path.dirname(outputDir),
      'REQUIREMENTS.md'
    );
    await fs.writeFile(requirementsPath, requirements, 'utf-8');

    context.logger.info(`Requirements generated: ${requirementsPath}`);

    return this.success(
      {
        requirementsPath,
        sourceType: detection.source.type,
      },
      [requirementsPath],
      [
        {
          type: 'documentation',
          url: requirementsPath,
          description: 'Generated requirements document',
        },
      ]
    );
  }

  private async generateRequirements(
    sourceType: string,
    sourceValue: string,
    context: CommandContext
  ): Promise<string> {
    const timestamp = new Date().toISOString();

    // Template for requirements document
    const template = `# Requirements Document

**Generated**: ${timestamp}
**Source Type**: ${sourceType}
**Source**: ${sourceValue}

---

## 1. Overview

This document contains the requirements extracted from the input source.

## 2. Functional Requirements

### 2.1 Core Features

- [ ] Feature 1: [To be extracted from source]
- [ ] Feature 2: [To be extracted from source]

### 2.2 User Interface

- [ ] UI Component 1: [To be extracted from source]
- [ ] UI Component 2: [To be extracted from source]

## 3. Non-Functional Requirements

### 3.1 Performance

- Response time: < 200ms
- Concurrent users: 1000+

### 3.2 Security

- Authentication required
- Data encryption at rest and in transit

## 4. Technical Requirements

### 4.1 Technology Stack

- Frontend: React/Next.js
- Backend: Node.js/Express
- Database: PostgreSQL

### 4.2 Infrastructure

- Cloud Provider: AWS
- Deployment: App Runner / ECS

## 5. Constraints

- Budget constraints
- Timeline constraints
- Resource constraints

---

*This document was automatically generated by CCAGI SDK v6.19.0*
`;

    return template;
  }

  protected async validateInternal(
    context: CommandContext
  ): Promise<ValidationError[]> {
    const errors: ValidationError[] = [];

    if (!context.options.url) {
      errors.push({
        code: 'MISSING_URL',
        message: 'URL or input source is required for requirements generation',
        field: 'url',
      });
    }

    return errors;
  }
}

// =============================================================================
// CMD-002: Add Requirements
// =============================================================================

/**
 * Add Requirements Handler
 *
 * Adds additional requirements to existing document
 */
export class AddRequirementsHandler extends BaseCommandHandler<{
  addedPath: string;
  itemsAdded: number;
}> {
  constructor() {
    super('CMD-002', '/add-requirements');
  }

  protected async executeInternal(
    context: CommandContext
  ): Promise<CommandHandlerResult<{ addedPath: string; itemsAdded: number }>> {
    const additionalText = context.options.text as string;

    // Create output path
    const outputDir = path.dirname(this.resolveOutputPath(context));
    const additionalPath = path.join(outputDir, 'ADDITIONAL_REQUIREMENTS.md');

    // Parse and format additional requirements
    const formattedContent = this.formatAdditionalRequirements(additionalText);

    // Write to file
    await fs.writeFile(additionalPath, formattedContent, 'utf-8');

    // Count items added
    const itemsAdded = (formattedContent.match(/^- /gm) || []).length;

    context.logger.info(
      `Added ${itemsAdded} additional requirements to ${additionalPath}`
    );

    return this.success(
      {
        addedPath: additionalPath,
        itemsAdded,
      },
      [additionalPath]
    );
  }

  private formatAdditionalRequirements(text: string): string {
    const timestamp = new Date().toISOString();

    return `# Additional Requirements

**Added**: ${timestamp}

---

## Additional Items

${text
  .split('\n')
  .filter((line) => line.trim())
  .map((line) => `- ${line.trim()}`)
  .join('\n')}

---

*Added by CCAGI SDK v6.19.0*
`;
  }

  protected async validateInternal(
    context: CommandContext
  ): Promise<ValidationError[]> {
    const errors: ValidationError[] = [];

    if (!context.options.text) {
      errors.push({
        code: 'MISSING_TEXT',
        message: 'Text content is required for adding requirements',
        field: 'text',
      });
    }

    return errors;
  }
}

// =============================================================================
// Registration
// =============================================================================

/**
 * Register Phase 1 handlers
 */
export function registerPhase1Handlers(): void {
  registerCommand(new GenerateRequirementsHandler());
  registerCommand(new AddRequirementsHandler());
}

/**
 * Get Phase 1 handlers
 */
export function getPhase1Handlers(): BaseCommandHandler[] {
  return [new GenerateRequirementsHandler(), new AddRequirementsHandler()];
}
